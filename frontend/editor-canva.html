<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artify - Canva Style Editor</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }

        /* Main Layout */
        .canva-layout {
            display: grid;
            grid-template-areas:
                "header header header"
                "sidebar canvas properties";
            grid-template-columns: 80px 1fr 320px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            background: #f0f0f0;
        }

        /* Header */
        .canva-header {
            grid-area: header;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .project-name {
            font-size: 14px;
            color: #666;
        }

        .header-center {
            display: flex;
            gap: 10px;
        }

        .header-btn {
            padding: 8px 16px;
            border: 1px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .header-btn:hover {
            background: #f5f5f5;
        }

        .header-btn.primary {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .header-btn.primary:hover {
            background: #5568d3;
        }

        /* Left Sidebar - Tool Palette */
        .left-sidebar {
            grid-area: sidebar;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            gap: 10px;
        }

        .tool-item {
            width: 60px;
            height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            font-size: 24px;
            position: relative;
        }

        .tool-item:hover {
            background: #f5f5f5;
        }

        .tool-item.active {
            background: #e8eaff;
            color: #667eea;
        }

        .tool-label {
            font-size: 10px;
            margin-top: 4px;
        }

        /* Canvas Area */
        .canvas-container {
            grid-area: canvas;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            overflow: auto;
            background: #e5e5e5;
        }

        .canvas-wrapper {
            position: relative;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        #mainCanvas {
            background: white;
            cursor: crosshair;
        }

        /* Right Properties Panel */
        .properties-panel {
            grid-area: properties;
            background: white;
            border-left: 1px solid #e0e0e0;
            overflow-y: auto;
            padding: 20px;
        }

        .panel-section {
            margin-bottom: 30px;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .panel-group {
            margin-bottom: 15px;
        }

        .panel-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 6px;
            display: block;
        }

        .panel-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
        }

        .panel-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.active {
            border-color: #667eea;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #667eea;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-group input[type="range"] {
            flex: 1;
        }

        .slider-value {
            min-width: 40px;
            text-align: right;
            font-size: 12px;
            color: #666;
        }

        /* Layers Panel */
        .layers-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
        }

        .layer-item {
            padding: 10px;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s;
        }

        .layer-item:hover {
            background: #f5f5f5;
        }

        .layer-item.active {
            background: #e8eaff;
            border-left: 3px solid #667eea;
        }

        .layer-icon {
            margin-right: 8px;
        }

        .layer-actions {
            display: flex;
            gap: 5px;
        }

        .layer-btn {
            padding: 4px 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 12px;
            border-radius: 4px;
        }

        .layer-btn:hover {
            background: #e0e0e0;
        }

        /* AI Panel */
        .ai-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 12px;
            color: white;
            margin-bottom: 20px;
        }

        .ai-panel textarea {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            resize: vertical;
            min-height: 80px;
            margin-bottom: 10px;
        }

        .ai-panel select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .ai-btn {
            width: 100%;
            padding: 12px;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .ai-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .ai-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Button Groups */
        .btn-group {
            display: flex;
            gap: 8px;
        }

        .btn-icon {
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: #f5f5f5;
        }

        .btn-icon:active {
            background: #e8eaff;
        }

        /* Font Selector */
        .font-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .font-option {
            padding: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .font-option:hover {
            background: #f5f5f5;
        }

        .font-option.active {
            background: #e8eaff;
            border-color: #667eea;
        }

        /* Messages */
        .message {
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 14px;
            text-align: center;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
        }

        .message.loading {
            background: #d1ecf1;
            color: #0c5460;
        }

        /* Image Upload */
        .upload-area {
            border: 2px dashed #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .upload-area input {
            display: none;
        }
    </style>
</head>
<body>
    <div class="canva-layout">
        <!-- Header -->
        <div class="canva-header">
            <div class="header-left">
                <div class="logo">Artify</div>
                <div class="project-name" id="projectName">ìƒˆ í”„ë¡œì íŠ¸</div>
            </div>
            <div class="header-center">
                <button class="header-btn" onclick="undo()" id="undoBtn" disabled aria-label="ì‹¤í–‰ ì·¨ì†Œ" title="ì‹¤í–‰ ì·¨ì†Œ (Ctrl+Z)">
                    â†¶ ì‹¤í–‰ ì·¨ì†Œ
                </button>
                <button class="header-btn" onclick="redo()" id="redoBtn" disabled aria-label="ë‹¤ì‹œ ì‹¤í–‰" title="ë‹¤ì‹œ ì‹¤í–‰ (Ctrl+Y)">
                    â†· ë‹¤ì‹œ ì‹¤í–‰
                </button>
            </div>
            <div class="header-right">
                <button class="header-btn" onclick="location.href='index.html'" aria-label="í”„ë¡œì íŠ¸ ëª©ë¡ìœ¼ë¡œ ëŒì•„ê°€ê¸°">â† ëª©ë¡</button>
                <button class="header-btn primary" onclick="saveProject()" aria-label="í”„ë¡œì íŠ¸ ì €ì¥">ğŸ’¾ ì €ì¥</button>
                <button class="header-btn" onclick="handleLogout()" aria-label="ë¡œê·¸ì•„ì›ƒ">ë¡œê·¸ì•„ì›ƒ</button>
            </div>
        </div>

        <!-- Left Sidebar - Tools -->
        <div class="left-sidebar" role="toolbar" aria-label="ë„êµ¬ ëª¨ìŒ">
            <div class="tool-item active" onclick="setTool('select')" data-tool="select" role="button" aria-label="ì„ íƒ ë„êµ¬" tabindex="0">
                <div>â¬œ</div>
                <div class="tool-label">ì„ íƒ</div>
            </div>
            <div class="tool-item" onclick="setTool('text')" data-tool="text" role="button" aria-label="í…ìŠ¤íŠ¸ ë„êµ¬" tabindex="0">
                <div>T</div>
                <div class="tool-label">í…ìŠ¤íŠ¸</div>
            </div>
            <div class="tool-item" onclick="setTool('rect')" data-tool="rect" role="button" aria-label="ì‚¬ê°í˜• ë„êµ¬" tabindex="0">
                <div>â–¢</div>
                <div class="tool-label">ì‚¬ê°í˜•</div>
            </div>
            <div class="tool-item" onclick="setTool('circle')" data-tool="circle" role="button" aria-label="ì› ë„êµ¬" tabindex="0">
                <div>â—‹</div>
                <div class="tool-label">ì›</div>
            </div>
            <div class="tool-item" onclick="setTool('triangle')" data-tool="triangle" role="button" aria-label="ì‚¼ê°í˜• ë„êµ¬" tabindex="0">
                <div>â–³</div>
                <div class="tool-label">ì‚¼ê°í˜•</div>
            </div>
            <div class="tool-item" onclick="setTool('star')" data-tool="star" role="button" aria-label="ë³„ ë„êµ¬" tabindex="0">
                <div>â˜…</div>
                <div class="tool-label">ë³„</div>
            </div>
            <div class="tool-item" onclick="setTool('line')" data-tool="line" role="button" aria-label="ì„  ë„êµ¬" tabindex="0">
                <div>â”€</div>
                <div class="tool-label">ì„ </div>
            </div>
            <div class="tool-item" onclick="setTool('arrow')" data-tool="arrow" role="button" aria-label="í™”ì‚´í‘œ ë„êµ¬" tabindex="0">
                <div>â†’</div>
                <div class="tool-label">í™”ì‚´í‘œ</div>
            </div>
            <div class="tool-item" onclick="setTool('pencil')" data-tool="pencil" role="button" aria-label="íœ ë„êµ¬" tabindex="0">
                <div>âœï¸</div>
                <div class="tool-label">íœ</div>
            </div>
            <div class="tool-item" onclick="document.getElementById('imageUpload').click()" role="button" aria-label="ì´ë¯¸ì§€ ì—…ë¡œë“œ" tabindex="0">
                <div>ğŸ–¼ï¸</div>
                <div class="tool-label">ì´ë¯¸ì§€</div>
            </div>
            <input type="file" id="imageUpload" accept="image/*" style="display:none" onchange="handleImageUpload(event)" aria-label="ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ">
        </div>

        <!-- Canvas Area -->
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <canvas id="mainCanvas" width="1200" height="800" role="img" aria-label="ë””ìì¸ ìº”ë²„ìŠ¤"></canvas>
            </div>
        </div>

        <!-- Right Properties Panel -->
        <div class="properties-panel">
            <!-- AI Generation -->
            <div class="ai-panel">
                <div class="panel-title" style="color: white; margin-bottom: 10px;">ğŸ¤– AI ì´ë¯¸ì§€ ìƒì„±</div>
                <textarea id="aiPrompt" placeholder="ì›í•˜ëŠ” ì´ë¯¸ì§€ë¥¼ ì„¤ëª…í•˜ì„¸ìš”..."></textarea>
                <select id="aiSize">
                    <option value="1024x1024">ì •ì‚¬ê°í˜• (1024x1024)</option>
                    <option value="1792x1024">ê°€ë¡œí˜• (1792x1024)</option>
                    <option value="1024x1792">ì„¸ë¡œí˜• (1024x1792)</option>
                </select>
                <button class="ai-btn" onclick="generateAIImage()" id="aiBtn">ì´ë¯¸ì§€ ìƒì„±</button>
                <div id="aiMessage"></div>
            </div>

            <!-- Element Properties -->
            <div class="panel-section" id="elementProps" style="display:none;">
                <div class="panel-title">ìš”ì†Œ ì†ì„±</div>

                <div class="panel-group">
                    <label class="panel-label">ìœ„ì¹˜ X</label>
                    <input type="number" class="panel-input" id="propX" oninput="updateElementProp('x', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">ìœ„ì¹˜ Y</label>
                    <input type="number" class="panel-input" id="propY" oninput="updateElementProp('y', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">ë„ˆë¹„</label>
                    <input type="number" class="panel-input" id="propWidth" oninput="updateElementProp('width', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">ë†’ì´</label>
                    <input type="number" class="panel-input" id="propHeight" oninput="updateElementProp('height', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">íšŒì „ (ë„)</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="360" value="0" id="propRotation" oninput="updateElementProp('rotation', this.value)">
                        <span class="slider-value" id="rotationValue">0Â°</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">ë¶ˆíˆ¬ëª…ë„</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="100" value="100" id="propOpacity" oninput="updateElementProp('opacity', this.value)">
                        <span class="slider-value" id="opacityValue">100%</span>
                    </div>
                </div>
            </div>

            <!-- Text Properties -->
            <div class="panel-section" id="textProps" style="display:none;">
                <div class="panel-title">í…ìŠ¤íŠ¸ ì†ì„±</div>

                <div class="panel-group">
                    <label class="panel-label">ë‚´ìš©</label>
                    <input type="text" class="panel-input" id="propText" oninput="updateElementProp('text', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">í°íŠ¸</label>
                    <select class="panel-input" id="propFont" onchange="updateElementProp('fontFamily', this.value)">
                        <option value="Arial">Arial</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Comic Sans MS">Comic Sans MS</option>
                    </select>
                </div>

                <div class="panel-group">
                    <label class="panel-label">í¬ê¸°</label>
                    <div class="slider-group">
                        <input type="range" min="8" max="120" value="24" id="propFontSize" oninput="updateElementProp('fontSize', this.value)">
                        <span class="slider-value" id="fontSizeValue">24px</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">ìŠ¤íƒ€ì¼</label>
                    <div class="btn-group">
                        <button class="btn-icon" onclick="toggleTextStyle('bold')" id="btnBold">
                            <strong>B</strong>
                        </button>
                        <button class="btn-icon" onclick="toggleTextStyle('italic')" id="btnItalic">
                            <em>I</em>
                        </button>
                        <button class="btn-icon" onclick="toggleTextStyle('underline')" id="btnUnderline">
                            <u>U</u>
                        </button>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">ì •ë ¬</label>
                    <div class="btn-group">
                        <button class="btn-icon" onclick="updateElementProp('textAlign', 'left')">â¬…ï¸</button>
                        <button class="btn-icon" onclick="updateElementProp('textAlign', 'center')">â†”ï¸</button>
                        <button class="btn-icon" onclick="updateElementProp('textAlign', 'right')">â¡ï¸</button>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">
                        <input type="checkbox" id="textShadowEnabled" onchange="toggleTextShadow(this.checked)">
                        í…ìŠ¤íŠ¸ ê·¸ë¦¼ì
                    </label>
                </div>

                <div id="textShadowControls" style="display:none;">
                    <div class="panel-group">
                        <label class="panel-label">X ì˜¤í”„ì…‹</label>
                        <div class="slider-group">
                            <input type="range" min="-20" max="20" value="2" id="shadowOffsetX" oninput="updateTextShadow('offsetX', this.value)">
                            <span class="slider-value" id="shadowXValue">2px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">Y ì˜¤í”„ì…‹</label>
                        <div class="slider-group">
                            <input type="range" min="-20" max="20" value="2" id="shadowOffsetY" oninput="updateTextShadow('offsetY', this.value)">
                            <span class="slider-value" id="shadowYValue">2px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">ë¸”ëŸ¬ ë°˜ê²½</label>
                        <div class="slider-group">
                            <input type="range" min="0" max="20" value="4" id="shadowBlur" oninput="updateTextShadow('blur', this.value)">
                            <span class="slider-value" id="shadowBlurValue">4px</span>
                        </div>
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">ê·¸ë¦¼ì ìƒ‰ìƒ</label>
                        <input type="color" class="panel-input" id="shadowColor" value="#000000" onchange="updateTextShadow('color', this.value)">
                    </div>
                </div>
            </div>

            <!-- Image Filter Properties -->
            <div class="panel-section" id="imageProps" style="display:none;">
                <div class="panel-title">ì´ë¯¸ì§€ í•„í„°</div>

                <div class="panel-group">
                    <label class="panel-label">Grayscale</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="100" value="0" id="filterGrayscale" oninput="updateImageFilter('grayscale', this.value)">
                        <span class="slider-value" id="grayscaleValue">0%</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Sepia</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="100" value="0" id="filterSepia" oninput="updateImageFilter('sepia', this.value)">
                        <span class="slider-value" id="sepiaValue">0%</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Blur</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="10" value="0" id="filterBlur" oninput="updateImageFilter('blur', this.value)">
                        <span class="slider-value" id="blurValue">0px</span>
                    </div>
                </div>

                <div class="panel-group">
                    <label class="panel-label">Brightness</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="200" value="100" id="filterBrightness" oninput="updateImageFilter('brightness', this.value)">
                        <span class="slider-value" id="brightnessValue">100%</span>
                    </div>
                </div>

                <button class="btn-icon" onclick="resetImageFilters()" style="width: 100%;">í•„í„° ì´ˆê¸°í™”</button>
            </div>

            <!-- Color Properties -->
            <div class="panel-section">
                <div class="panel-title">ìƒ‰ìƒ</div>

                <div class="panel-group">
                    <label class="panel-label">ì±„ìš°ê¸°</label>
                    <input type="color" class="panel-input" id="propFill" value="#667eea" onchange="updateElementProp('fill', this.value)">
                </div>

                <div class="color-grid">
                    <div class="color-swatch" style="background: #667eea" onclick="setColor('#667eea')"></div>
                    <div class="color-swatch" style="background: #764ba2" onclick="setColor('#764ba2')"></div>
                    <div class="color-swatch" style="background: #f093fb" onclick="setColor('#f093fb')"></div>
                    <div class="color-swatch" style="background: #4facfe" onclick="setColor('#4facfe')"></div>
                    <div class="color-swatch" style="background: #43e97b" onclick="setColor('#43e97b')"></div>
                    <div class="color-swatch" style="background: #fa709a" onclick="setColor('#fa709a')"></div>
                    <div class="color-swatch" style="background: #fee140" onclick="setColor('#fee140')"></div>
                    <div class="color-swatch" style="background: #30cfd0" onclick="setColor('#30cfd0')"></div>
                    <div class="color-swatch" style="background: #ff6b6b" onclick="setColor('#ff6b6b')"></div>
                    <div class="color-swatch" style="background: #4ecdc4" onclick="setColor('#4ecdc4')"></div>
                    <div class="color-swatch" style="background: #45b7d1" onclick="setColor('#45b7d1')"></div>
                    <div class="color-swatch" style="background: #96ceb4" onclick="setColor('#96ceb4')"></div>
                </div>

                <div class="panel-group" style="margin-top: 15px;">
                    <label class="panel-label">í…Œë‘ë¦¬ ìƒ‰ìƒ</label>
                    <input type="color" class="panel-input" id="propStroke" value="#000000" onchange="updateElementProp('stroke', this.value)">
                </div>

                <div class="panel-group">
                    <label class="panel-label">í…Œë‘ë¦¬ ë‘ê»˜</label>
                    <div class="slider-group">
                        <input type="range" min="0" max="20" value="2" id="propStrokeWidth" oninput="updateElementProp('strokeWidth', this.value)">
                        <span class="slider-value" id="strokeValue">2px</span>
                    </div>
                </div>

                <div class="panel-group" id="gradientSection" style="display:none;">
                    <label class="panel-label">
                        <input type="checkbox" id="gradientEnabled" onchange="toggleGradient(this.checked)">
                        ê·¸ë¼ë°ì´ì…˜ ì±„ìš°ê¸°
                    </label>
                </div>

                <div id="gradientControls" style="display:none;">
                    <div class="panel-group">
                        <label class="panel-label">ì‹œì‘ ìƒ‰ìƒ</label>
                        <input type="color" class="panel-input" id="gradientColor1" value="#667eea" onchange="updateGradient('color1', this.value)">
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">ë ìƒ‰ìƒ</label>
                        <input type="color" class="panel-input" id="gradientColor2" value="#764ba2" onchange="updateGradient('color2', this.value)">
                    </div>

                    <div class="panel-group">
                        <label class="panel-label">ê°ë„</label>
                        <div class="slider-group">
                            <input type="range" min="0" max="360" value="0" id="gradientAngle" oninput="updateGradient('angle', this.value)">
                            <span class="slider-value" id="angleValue">0Â°</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Layers -->
            <div class="panel-section">
                <div class="panel-title">ë ˆì´ì–´</div>
                <div class="layers-list" id="layersList">
                    <div style="padding: 20px; text-align: center; color: #999;">
                        ìš”ì†Œë¥¼ ì¶”ê°€í•˜ì„¸ìš”
                    </div>
                </div>
                <div class="btn-group" style="margin-top: 10px;">
                    <button class="btn-icon" onclick="moveLayer('up')" style="flex:1">â†‘ ìœ„ë¡œ</button>
                    <button class="btn-icon" onclick="moveLayer('down')" style="flex:1">â†“ ì•„ë˜ë¡œ</button>
                    <button class="btn-icon" onclick="deleteSelected()" style="flex:1">ğŸ—‘ï¸ ì‚­ì œ</button>
                </div>
            </div>

            <!-- Alignment Tools -->
            <div class="panel-section">
                <div class="panel-title">ì •ë ¬</div>
                <div class="btn-group">
                    <button class="btn-icon" onclick="alignElements('left')" title="ì™¼ìª½ ì •ë ¬">â¬…ï¸</button>
                    <button class="btn-icon" onclick="alignElements('center')" title="ì¤‘ì•™ ì •ë ¬">â†”ï¸</button>
                    <button class="btn-icon" onclick="alignElements('right')" title="ì˜¤ë¥¸ìª½ ì •ë ¬">â¡ï¸</button>
                </div>
                <div class="btn-group" style="margin-top: 8px;">
                    <button class="btn-icon" onclick="alignElements('top')" title="ìœ„ìª½ ì •ë ¬">â¬†ï¸</button>
                    <button class="btn-icon" onclick="alignElements('middle')" title="ì¤‘ê°„ ì •ë ¬">â†•ï¸</button>
                    <button class="btn-icon" onclick="alignElements('bottom')" title="ì•„ë˜ìª½ ì •ë ¬">â¬‡ï¸</button>
                </div>
            </div>

            <div id="saveMessage"></div>
        </div>
    </div>

    <script src="config.js"></script>
    <script>
        // Global State
        let canvas, ctx;
        let elements = [];
        let selectedElement = null;
        let selectedElements = [];
        let currentTool = 'select';
        let isDrawing = false;
        let isDragging = false;
        let isResizing = false;
        let dragStart = {x: 0, y: 0};
        let resizeHandle = null;
        let history = [];
        let historyIndex = -1;
        let currentProjectId = null;
        let gridEnabled = true;
        let snapEnabled = true;
        let nextGroupId = 1;
        let imageCache = new Map();
        let clipboard = null;
        let autoSaveInterval = null;
        let lastSaveTime = null;
        let isDirty = true;
        let renderScheduled = false;

        // Element class
        class Element {
            constructor(type, x, y, width, height) {
                this.id = Date.now() + Math.random();
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.rotation = 0;
                this.fill = '#667eea';
                this.stroke = '#000000';
                this.strokeWidth = 2;
                this.opacity = 1;
                this.visible = true;
                this.locked = false;
                this.groupId = null;
                this.gradient = {
                    enabled: false,
                    type: 'linear',
                    color1: '#667eea',
                    color2: '#764ba2',
                    angle: 0
                };

                // Text specific
                if (type === 'text') {
                    this.text = 'í…ìŠ¤íŠ¸ ì…ë ¥';
                    this.fontSize = 24;
                    this.fontFamily = 'Arial';
                    this.textAlign = 'left';
                    this.bold = false;
                    this.italic = false;
                    this.underline = false;
                    this.textShadow = {
                        enabled: false,
                        offsetX: 2,
                        offsetY: 2,
                        blur: 4,
                        color: '#000000'
                    };
                }

                // Image specific
                if (type === 'image') {
                    this.imageData = null;
                    this.filters = {
                        grayscale: 0,
                        sepia: 0,
                        blur: 0,
                        brightness: 100
                    };
                }

                // Drawing path specific
                if (type === 'pencil') {
                    this.points = [];
                }
            }

            draw(context) {
                if (!this.visible) return;

                context.save();
                context.globalAlpha = this.opacity;
                context.translate(this.x + this.width / 2, this.y + this.height / 2);
                context.rotate(this.rotation * Math.PI / 180);
                context.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));

                switch (this.type) {
                    case 'rect':
                        // Apply gradient or solid fill
                        if (this.gradient && this.gradient.enabled) {
                            const angle = this.gradient.angle * Math.PI / 180;
                            const x0 = this.x + this.width / 2 - Math.cos(angle) * this.width / 2;
                            const y0 = this.y + this.height / 2 - Math.sin(angle) * this.height / 2;
                            const x1 = this.x + this.width / 2 + Math.cos(angle) * this.width / 2;
                            const y1 = this.y + this.height / 2 + Math.sin(angle) * this.height / 2;
                            const gradient = context.createLinearGradient(x0, y0, x1, y1);
                            gradient.addColorStop(0, this.gradient.color1);
                            gradient.addColorStop(1, this.gradient.color2);
                            context.fillStyle = gradient;
                        } else {
                            context.fillStyle = this.fill;
                        }
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.fillRect(this.x, this.y, this.width, this.height);
                        if (this.strokeWidth > 0) {
                            context.strokeRect(this.x, this.y, this.width, this.height);
                        }
                        break;

                    case 'circle':
                        // Apply gradient or solid fill
                        if (this.gradient && this.gradient.enabled) {
                            const angle = this.gradient.angle * Math.PI / 180;
                            const radiusX = this.width / 2;
                            const radiusY = this.height / 2;
                            const cx = this.x + radiusX;
                            const cy = this.y + radiusY;
                            const x0 = cx - Math.cos(angle) * radiusX;
                            const y0 = cy - Math.sin(angle) * radiusY;
                            const x1 = cx + Math.cos(angle) * radiusX;
                            const y1 = cy + Math.sin(angle) * radiusY;
                            const gradient = context.createLinearGradient(x0, y0, x1, y1);
                            gradient.addColorStop(0, this.gradient.color1);
                            gradient.addColorStop(1, this.gradient.color2);
                            context.fillStyle = gradient;
                        } else {
                            context.fillStyle = this.fill;
                        }
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.beginPath();
                        const radiusX = this.width / 2;
                        const radiusY = this.height / 2;
                        context.ellipse(this.x + radiusX, this.y + radiusY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                        context.fill();
                        if (this.strokeWidth > 0) {
                            context.stroke();
                        }
                        break;

                    case 'triangle':
                        context.fillStyle = this.fill;
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.beginPath();
                        context.moveTo(this.x + this.width / 2, this.y);
                        context.lineTo(this.x + this.width, this.y + this.height);
                        context.lineTo(this.x, this.y + this.height);
                        context.closePath();
                        context.fill();
                        if (this.strokeWidth > 0) {
                            context.stroke();
                        }
                        break;

                    case 'star':
                        this.drawStar(context);
                        break;

                    case 'line':
                        context.strokeStyle = this.stroke;
                        context.lineWidth = this.strokeWidth;
                        context.beginPath();
                        context.moveTo(this.x, this.y);
                        context.lineTo(this.x + this.width, this.y + this.height);
                        context.stroke();
                        break;

                    case 'arrow':
                        this.drawArrow(context);
                        break;

                    case 'text':
                        context.fillStyle = this.fill;
                        let fontStyle = '';
                        if (this.italic) fontStyle += 'italic ';
                        if (this.bold) fontStyle += 'bold ';
                        context.font = `${fontStyle}${this.fontSize}px ${this.fontFamily}`;
                        context.textAlign = this.textAlign;
                        context.textBaseline = 'top';

                        // Apply text shadow if enabled
                        if (this.textShadow && this.textShadow.enabled) {
                            context.shadowOffsetX = this.textShadow.offsetX;
                            context.shadowOffsetY = this.textShadow.offsetY;
                            context.shadowBlur = this.textShadow.blur;
                            context.shadowColor = this.textShadow.color;
                        }

                        let textX = this.x;
                        if (this.textAlign === 'center') textX += this.width / 2;
                        else if (this.textAlign === 'right') textX += this.width;

                        context.fillText(this.text, textX, this.y);

                        // Reset shadow
                        context.shadowOffsetX = 0;
                        context.shadowOffsetY = 0;
                        context.shadowBlur = 0;
                        context.shadowColor = 'transparent';

                        if (this.underline) {
                            const metrics = context.measureText(this.text);
                            context.beginPath();
                            context.moveTo(textX, this.y + this.fontSize + 2);
                            context.lineTo(textX + metrics.width, this.y + this.fontSize + 2);
                            context.strokeStyle = this.fill;
                            context.lineWidth = 1;
                            context.stroke();
                        }
                        break;

                    case 'image':
                        if (this.imageData) {
                            // Apply filters
                            if (this.filters) {
                                const filterParts = [];
                                if (this.filters.grayscale > 0) filterParts.push(`grayscale(${this.filters.grayscale}%)`);
                                if (this.filters.sepia > 0) filterParts.push(`sepia(${this.filters.sepia}%)`);
                                if (this.filters.blur > 0) filterParts.push(`blur(${this.filters.blur}px)`);
                                if (this.filters.brightness !== 100) filterParts.push(`brightness(${this.filters.brightness}%)`);
                                context.filter = filterParts.length > 0 ? filterParts.join(' ') : 'none';
                            }
                            context.drawImage(this.imageData, this.x, this.y, this.width, this.height);
                            context.filter = 'none';
                        }
                        break;

                    case 'pencil':
                        if (this.points.length > 0) {
                            context.strokeStyle = this.stroke;
                            context.lineWidth = this.strokeWidth;
                            context.lineCap = 'round';
                            context.lineJoin = 'round';
                            context.beginPath();
                            context.moveTo(this.points[0].x, this.points[0].y);
                            for (let i = 1; i < this.points.length; i++) {
                                context.lineTo(this.points[i].x, this.points[i].y);
                            }
                            context.stroke();
                        }
                        break;
                }

                context.restore();
            }

            drawStar(context) {
                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;
                const outerRadius = Math.min(this.width, this.height) / 2;
                const innerRadius = outerRadius / 2;
                const points = 5;

                context.fillStyle = this.fill;
                context.strokeStyle = this.stroke;
                context.lineWidth = this.strokeWidth;
                context.beginPath();

                for (let i = 0; i < points * 2; i++) {
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const angle = (i * Math.PI) / points - Math.PI / 2;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    if (i === 0) context.moveTo(x, y);
                    else context.lineTo(x, y);
                }

                context.closePath();
                context.fill();
                if (this.strokeWidth > 0) {
                    context.stroke();
                }
            }

            drawArrow(context) {
                const headLength = 20;
                const dx = this.width;
                const dy = this.height;
                const angle = Math.atan2(dy, dx);

                context.strokeStyle = this.stroke;
                context.fillStyle = this.stroke;
                context.lineWidth = this.strokeWidth;

                // Line
                context.beginPath();
                context.moveTo(this.x, this.y);
                context.lineTo(this.x + dx, this.y + dy);
                context.stroke();

                // Arrowhead
                context.beginPath();
                context.moveTo(this.x + dx, this.y + dy);
                context.lineTo(
                    this.x + dx - headLength * Math.cos(angle - Math.PI / 6),
                    this.y + dy - headLength * Math.sin(angle - Math.PI / 6)
                );
                context.lineTo(
                    this.x + dx - headLength * Math.cos(angle + Math.PI / 6),
                    this.y + dy - headLength * Math.sin(angle + Math.PI / 6)
                );
                context.closePath();
                context.fill();
            }

            contains(x, y) {
                if (this.type === 'pencil') {
                    // Check if point is near any line segment
                    for (let i = 0; i < this.points.length - 1; i++) {
                        const dist = this.distanceToSegment(x, y, this.points[i], this.points[i + 1]);
                        if (dist < this.strokeWidth + 5) return true;
                    }
                    return false;
                }

                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }

            distanceToSegment(px, py, p1, p2) {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                if (len === 0) return Math.sqrt((px - p1.x) ** 2 + (py - p1.y) ** 2);

                const t = Math.max(0, Math.min(1, ((px - p1.x) * dx + (py - p1.y) * dy) / (len * len)));
                const projX = p1.x + t * dx;
                const projY = p1.y + t * dy;
                return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
            }

            getResizeHandle(x, y) {
                if (this.type === 'pencil') return null;

                const handles = [
                    {name: 'nw', x: this.x, y: this.y},
                    {name: 'ne', x: this.x + this.width, y: this.y},
                    {name: 'sw', x: this.x, y: this.y + this.height},
                    {name: 'se', x: this.x + this.width, y: this.y + this.height},
                ];

                for (let handle of handles) {
                    if (Math.abs(x - handle.x) < 8 && Math.abs(y - handle.y) < 8) {
                        return handle.name;
                    }
                }
                return null;
            }
        }

        // Initialize
        window.onload = function() {
            if (!checkAuth()) return;

            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');

            const urlParams = new URLSearchParams(window.location.search);
            currentProjectId = urlParams.get('id');

            if (currentProjectId) {
                loadProject(currentProjectId);
                // Enable auto-save every 5 minutes
                autoSaveInterval = setInterval(autoSave, 5 * 60 * 1000);
            } else {
                render();
            }

            setupEventListeners();
            setupOnlineStatusListener();
        };

        function checkAuth() {
            const token = localStorage.getItem('token');
            if (!token) {
                alert('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                window.location.href = 'login.html';
                return false;
            }
            return true;
        }

        function handleLogout() {
            if (confirm('ë¡œê·¸ì•„ì›ƒ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                localStorage.clear();
                window.location.href = 'login.html';
            }
        }

        function setupEventListeners() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('dblclick', handleDoubleClick);

            document.addEventListener('keydown', handleKeyDown);
        }

        function setupOnlineStatusListener() {
            window.addEventListener('online', () => {
                console.log('ì˜¨ë¼ì¸ ìƒíƒœë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.');
                if (currentProjectId && elements.length > 0) {
                    autoSave();
                }
            });

            window.addEventListener('offline', () => {
                console.log('ì˜¤í”„ë¼ì¸ ìƒíƒœì…ë‹ˆë‹¤. ë³€ê²½ì‚¬í•­ì´ ì €ì¥ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            });
        }

        async function fetchWithRetry(url, options, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok || response.status === 404) {
                        return response;
                    }
                    if (i === maxRetries - 1) throw new Error('Max retries reached');
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                }
            }
        }

        async function autoSave() {
            if (!currentProjectId || elements.length === 0) return;

            try {
                const token = localStorage.getItem('token');
                const canvasData = canvas.toDataURL('image/jpeg', 0.8);

                const projectData = {
                    image: canvasData,
                    elements: elements.map(el => ({
                        ...el,
                        imageData: el.imageData ? el.imageData.src : null
                    })),
                    prompt: document.getElementById('aiPrompt').value,
                    lastModified: new Date().toISOString()
                };

                const response = await fetchWithRetry(`${API_URL}/projects/${currentProjectId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({
                        data: JSON.stringify(projectData)
                    })
                });

                if (response.ok) {
                    lastSaveTime = new Date();
                    console.log('ìë™ ì €ì¥ ì™„ë£Œ:', lastSaveTime.toLocaleTimeString());
                }
            } catch (error) {
                console.error('ìë™ ì €ì¥ ì‹¤íŒ¨:', error);
            }
        }

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (currentTool === 'select') {
                // Check for resize handle
                if (selectedElement) {
                    resizeHandle = selectedElement.getResizeHandle(x, y);
                    if (resizeHandle) {
                        isResizing = true;
                        dragStart = {x, y};
                        return;
                    }
                }

                // Check for element selection
                for (let i = elements.length - 1; i >= 0; i--) {
                    if (elements[i].contains(x, y) && !elements[i].locked) {
                        const clickedElement = elements[i];

                        // If element is part of a group, select all group members
                        if (clickedElement.groupId) {
                            selectedElements = elements.filter(el => el.groupId === clickedElement.groupId);
                            selectedElement = clickedElement;
                        } else if (e.ctrlKey || e.metaKey) {
                            // Ctrl+Click for multi-select
                            if (selectedElements.includes(clickedElement)) {
                                selectedElements = selectedElements.filter(el => el !== clickedElement);
                                selectedElement = selectedElements[0] || null;
                            } else {
                                selectedElements.push(clickedElement);
                                selectedElement = clickedElement;
                            }
                        } else {
                            // Single select
                            selectedElement = clickedElement;
                            selectedElements = [clickedElement];
                        }

                        isDragging = true;
                        dragStart = {x: x - selectedElement.x, y: y - selectedElement.y};
                        updatePropertiesPanel();
                        updateLayersList();
                        render();
                        return;
                    }
                }

                // Deselect
                selectedElement = null;
                selectedElements = [];
                updatePropertiesPanel();
                updateLayersList();
                render();
            } else if (currentTool === 'pencil') {
                isDrawing = true;
                const pencil = new Element('pencil', x, y, 0, 0);
                pencil.points.push({x, y});
                pencil.stroke = document.getElementById('propStroke').value;
                pencil.strokeWidth = parseInt(document.getElementById('propStrokeWidth').value);
                elements.push(pencil);
                selectedElement = pencil;
            } else {
                // Start drawing shape
                isDrawing = true;
                dragStart = {x, y};
            }
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (isDragging && selectedElement && !selectedElement.locked) {
                const newX = snapEnabled ? Math.round((x - dragStart.x) / 10) * 10 : x - dragStart.x;
                const newY = snapEnabled ? Math.round((y - dragStart.y) / 10) * 10 : y - dragStart.y;
                const deltaX = newX - selectedElement.x;
                const deltaY = newY - selectedElement.y;

                // Move selected element
                selectedElement.x = newX;
                selectedElement.y = newY;

                // Move other selected elements
                if (selectedElements.length > 1) {
                    selectedElements.forEach(el => {
                        if (el !== selectedElement && !el.locked) {
                            el.x += deltaX;
                            el.y += deltaY;
                        }
                    });
                }

                updatePropertiesPanel();
                render();
            } else if (isResizing && selectedElement) {
                const dx = x - dragStart.x;
                const dy = y - dragStart.y;

                switch (resizeHandle) {
                    case 'se':
                        selectedElement.width = Math.max(10, selectedElement.width + dx);
                        selectedElement.height = Math.max(10, selectedElement.height + dy);
                        break;
                    case 'sw':
                        selectedElement.width = Math.max(10, selectedElement.width - dx);
                        selectedElement.height = Math.max(10, selectedElement.height + dy);
                        selectedElement.x += dx;
                        break;
                    case 'ne':
                        selectedElement.width = Math.max(10, selectedElement.width + dx);
                        selectedElement.height = Math.max(10, selectedElement.height - dy);
                        selectedElement.y += dy;
                        break;
                    case 'nw':
                        selectedElement.width = Math.max(10, selectedElement.width - dx);
                        selectedElement.height = Math.max(10, selectedElement.height - dy);
                        selectedElement.x += dx;
                        selectedElement.y += dy;
                        break;
                }

                dragStart = {x, y};
                updatePropertiesPanel();
                render();
            } else if (isDrawing && currentTool === 'pencil' && selectedElement) {
                selectedElement.points.push({x, y});
                render();
            }
        }

        function handleMouseUp(e) {
            if (isDrawing && currentTool !== 'select' && currentTool !== 'pencil') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const width = x - dragStart.x;
                const height = y - dragStart.y;

                if (Math.abs(width) > 10 && Math.abs(height) > 10) {
                    const element = new Element(
                        currentTool,
                        Math.min(dragStart.x, x),
                        Math.min(dragStart.y, y),
                        Math.abs(width),
                        Math.abs(height)
                    );
                    element.fill = document.getElementById('propFill').value;
                    element.stroke = document.getElementById('propStroke').value;
                    element.strokeWidth = parseInt(document.getElementById('propStrokeWidth').value);

                    elements.push(element);
                    selectedElement = element;
                    saveHistory();
                    updatePropertiesPanel();
                    updateLayersList();
                    render();
                }
            } else if (currentTool === 'pencil' && selectedElement) {
                // Calculate bounding box for pencil
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                for (let point of selectedElement.points) {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                }
                selectedElement.x = minX;
                selectedElement.y = minY;
                selectedElement.width = maxX - minX;
                selectedElement.height = maxY - minY;

                saveHistory();
                updateLayersList();
            }

            isDragging = false;
            isDrawing = false;
            isResizing = false;
            resizeHandle = null;
        }

        function handleDoubleClick(e) {
            if (currentTool === 'text' || (selectedElement && selectedElement.type === 'text')) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (!selectedElement || selectedElement.type !== 'text') {
                    const text = new Element('text', x, y, 200, 40);
                    text.fill = document.getElementById('propFill').value;
                    elements.push(text);
                    selectedElement = text;
                    saveHistory();
                }

                const newText = prompt('í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”:', selectedElement.text);
                if (newText !== null) {
                    selectedElement.text = newText;
                    updatePropertiesPanel();
                    render();
                }
            }
        }

        function handleKeyDown(e) {
            if (e.key === 'Delete' && selectedElement) {
                deleteSelected();
            } else if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (e.ctrlKey && e.shiftKey && e.key === 'G') {
                e.preventDefault();
                ungroupElements();
            } else if (e.ctrlKey && e.key === 'g') {
                e.preventDefault();
                groupElements();
            } else if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                selectAll();
            } else if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                copySelected();
            } else if (e.ctrlKey && e.key === 'v') {
                e.preventDefault();
                pasteClipboard();
            } else if (e.ctrlKey && e.key === 'd') {
                e.preventDefault();
                duplicateSelected();
            } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                moveSelectedByArrow(e.key, e.ctrlKey);
            }
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');

            if (tool !== 'select') {
                selectedElement = null;
                updatePropertiesPanel();
                render();
            }
        }

        function render() {
            if (!isDirty && !renderScheduled) return;

            if (!renderScheduled) {
                renderScheduled = true;
                requestAnimationFrame(() => {
                    renderScheduled = false;
                    isDirty = false;
                    actualRender();
                });
            }
        }

        function actualRender() {
            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            if (gridEnabled) {
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1;
                for (let i = 0; i < canvas.width; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, canvas.height);
                    ctx.stroke();
                }
                for (let i = 0; i < canvas.height; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(canvas.width, i);
                    ctx.stroke();
                }
            }

            // Draw elements
            for (let element of elements) {
                element.draw(ctx);
            }

            // Draw selection
            if (currentTool === 'select') {
                // Draw all selected elements
                if (selectedElements.length > 1) {
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    selectedElements.forEach(el => {
                        ctx.strokeRect(el.x - 2, el.y - 2, el.width + 4, el.height + 4);
                    });
                    ctx.setLineDash([]);
                } else if (selectedElement) {
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(selectedElement.x - 2, selectedElement.y - 2,
                                  selectedElement.width + 4, selectedElement.height + 4);
                    ctx.setLineDash([]);

                    // Draw resize handles
                    if (selectedElement.type !== 'pencil') {
                        ctx.fillStyle = '#667eea';
                        const handles = [
                            {x: selectedElement.x, y: selectedElement.y},
                            {x: selectedElement.x + selectedElement.width, y: selectedElement.y},
                            {x: selectedElement.x, y: selectedElement.y + selectedElement.height},
                            {x: selectedElement.x + selectedElement.width, y: selectedElement.y + selectedElement.height},
                        ];
                        for (let handle of handles) {
                            ctx.fillRect(handle.x - 4, handle.y - 4, 8, 8);
                        }
                    }
                }
            }
        }

        function markDirty() {
            isDirty = true;
        }

        function updatePropertiesPanel() {
            const elementProps = document.getElementById('elementProps');
            const textProps = document.getElementById('textProps');
            const imageProps = document.getElementById('imageProps');
            const gradientSection = document.getElementById('gradientSection');

            if (selectedElement) {
                elementProps.style.display = 'block';
                document.getElementById('propX').value = Math.round(selectedElement.x);
                document.getElementById('propY').value = Math.round(selectedElement.y);
                document.getElementById('propWidth').value = Math.round(selectedElement.width);
                document.getElementById('propHeight').value = Math.round(selectedElement.height);
                document.getElementById('propRotation').value = selectedElement.rotation;
                document.getElementById('rotationValue').textContent = selectedElement.rotation + 'Â°';
                document.getElementById('propOpacity').value = selectedElement.opacity * 100;
                document.getElementById('opacityValue').textContent = Math.round(selectedElement.opacity * 100) + '%';
                document.getElementById('propFill').value = selectedElement.fill;
                document.getElementById('propStroke').value = selectedElement.stroke;
                document.getElementById('propStrokeWidth').value = selectedElement.strokeWidth;
                document.getElementById('strokeValue').textContent = selectedElement.strokeWidth + 'px';

                // Show gradient section for shapes
                if (['rect', 'circle', 'triangle', 'star'].includes(selectedElement.type)) {
                    gradientSection.style.display = 'block';
                    if (selectedElement.gradient) {
                        document.getElementById('gradientEnabled').checked = selectedElement.gradient.enabled;
                        document.getElementById('gradientControls').style.display = selectedElement.gradient.enabled ? 'block' : 'none';
                        document.getElementById('gradientColor1').value = selectedElement.gradient.color1;
                        document.getElementById('gradientColor2').value = selectedElement.gradient.color2;
                        document.getElementById('gradientAngle').value = selectedElement.gradient.angle;
                        document.getElementById('angleValue').textContent = selectedElement.gradient.angle + 'Â°';
                    }
                } else {
                    gradientSection.style.display = 'none';
                }

                if (selectedElement.type === 'text') {
                    textProps.style.display = 'block';
                    imageProps.style.display = 'none';
                    document.getElementById('propText').value = selectedElement.text;
                    document.getElementById('propFont').value = selectedElement.fontFamily;
                    document.getElementById('propFontSize').value = selectedElement.fontSize;
                    document.getElementById('fontSizeValue').textContent = selectedElement.fontSize + 'px';

                    // Update text shadow controls
                    if (selectedElement.textShadow) {
                        document.getElementById('textShadowEnabled').checked = selectedElement.textShadow.enabled;
                        document.getElementById('textShadowControls').style.display = selectedElement.textShadow.enabled ? 'block' : 'none';
                        document.getElementById('shadowOffsetX').value = selectedElement.textShadow.offsetX;
                        document.getElementById('shadowXValue').textContent = selectedElement.textShadow.offsetX + 'px';
                        document.getElementById('shadowOffsetY').value = selectedElement.textShadow.offsetY;
                        document.getElementById('shadowYValue').textContent = selectedElement.textShadow.offsetY + 'px';
                        document.getElementById('shadowBlur').value = selectedElement.textShadow.blur;
                        document.getElementById('shadowBlurValue').textContent = selectedElement.textShadow.blur + 'px';
                        document.getElementById('shadowColor').value = selectedElement.textShadow.color;
                    }
                } else if (selectedElement.type === 'image') {
                    textProps.style.display = 'none';
                    imageProps.style.display = 'block';

                    // Update image filter controls
                    if (selectedElement.filters) {
                        document.getElementById('filterGrayscale').value = selectedElement.filters.grayscale;
                        document.getElementById('grayscaleValue').textContent = selectedElement.filters.grayscale + '%';
                        document.getElementById('filterSepia').value = selectedElement.filters.sepia;
                        document.getElementById('sepiaValue').textContent = selectedElement.filters.sepia + '%';
                        document.getElementById('filterBlur').value = selectedElement.filters.blur;
                        document.getElementById('blurValue').textContent = selectedElement.filters.blur + 'px';
                        document.getElementById('filterBrightness').value = selectedElement.filters.brightness;
                        document.getElementById('brightnessValue').textContent = selectedElement.filters.brightness + '%';
                    }
                } else {
                    textProps.style.display = 'none';
                    imageProps.style.display = 'none';
                }
            } else {
                elementProps.style.display = 'none';
                textProps.style.display = 'none';
                imageProps.style.display = 'none';
            }
        }

        function updateElementProp(prop, value) {
            if (!selectedElement) return;

            switch (prop) {
                case 'x':
                case 'y':
                case 'width':
                case 'height':
                case 'fontSize':
                    selectedElement[prop] = parseFloat(value);
                    break;
                case 'rotation':
                    selectedElement[prop] = parseFloat(value);
                    document.getElementById('rotationValue').textContent = value + 'Â°';
                    break;
                case 'opacity':
                    selectedElement[prop] = parseFloat(value) / 100;
                    document.getElementById('opacityValue').textContent = value + '%';
                    break;
                case 'strokeWidth':
                    selectedElement[prop] = parseFloat(value);
                    document.getElementById('strokeValue').textContent = value + 'px';
                    break;
                default:
                    selectedElement[prop] = value;
            }

            render();
        }

        function toggleTextStyle(style) {
            if (!selectedElement || selectedElement.type !== 'text') return;

            selectedElement[style] = !selectedElement[style];
            render();
        }

        function toggleTextShadow(enabled) {
            if (!selectedElement || selectedElement.type !== 'text') return;

            if (!selectedElement.textShadow) {
                selectedElement.textShadow = {
                    enabled: false,
                    offsetX: 2,
                    offsetY: 2,
                    blur: 4,
                    color: '#000000'
                };
            }

            selectedElement.textShadow.enabled = enabled;
            document.getElementById('textShadowControls').style.display = enabled ? 'block' : 'none';
            render();
        }

        function updateTextShadow(prop, value) {
            if (!selectedElement || selectedElement.type !== 'text' || !selectedElement.textShadow) return;

            switch (prop) {
                case 'offsetX':
                    selectedElement.textShadow.offsetX = parseFloat(value);
                    document.getElementById('shadowXValue').textContent = value + 'px';
                    break;
                case 'offsetY':
                    selectedElement.textShadow.offsetY = parseFloat(value);
                    document.getElementById('shadowYValue').textContent = value + 'px';
                    break;
                case 'blur':
                    selectedElement.textShadow.blur = parseFloat(value);
                    document.getElementById('shadowBlurValue').textContent = value + 'px';
                    break;
                case 'color':
                    selectedElement.textShadow.color = value;
                    break;
            }

            render();
        }

        function setColor(color) {
            document.getElementById('propFill').value = color;
            if (selectedElement) {
                selectedElement.fill = color;
                render();
            }
        }

        function updateImageFilter(filterType, value) {
            if (!selectedElement || selectedElement.type !== 'image' || !selectedElement.filters) return;

            selectedElement.filters[filterType] = parseFloat(value);

            switch (filterType) {
                case 'grayscale':
                    document.getElementById('grayscaleValue').textContent = value + '%';
                    break;
                case 'sepia':
                    document.getElementById('sepiaValue').textContent = value + '%';
                    break;
                case 'blur':
                    document.getElementById('blurValue').textContent = value + 'px';
                    break;
                case 'brightness':
                    document.getElementById('brightnessValue').textContent = value + '%';
                    break;
            }

            render();
        }

        function resetImageFilters() {
            if (!selectedElement || selectedElement.type !== 'image') return;

            selectedElement.filters = {
                grayscale: 0,
                sepia: 0,
                blur: 0,
                brightness: 100
            };

            updatePropertiesPanel();
            render();
        }

        function toggleGradient(enabled) {
            if (!selectedElement || !selectedElement.gradient) return;

            selectedElement.gradient.enabled = enabled;
            document.getElementById('gradientControls').style.display = enabled ? 'block' : 'none';
            render();
        }

        function updateGradient(prop, value) {
            if (!selectedElement || !selectedElement.gradient) return;

            selectedElement.gradient[prop] = prop === 'angle' ? parseFloat(value) : value;

            if (prop === 'angle') {
                document.getElementById('angleValue').textContent = value + 'Â°';
            }

            render();
        }

        function updateLayersList() {
            const layersList = document.getElementById('layersList');

            if (elements.length === 0) {
                layersList.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">ìš”ì†Œë¥¼ ì¶”ê°€í•˜ì„¸ìš”</div>';
                return;
            }

            layersList.innerHTML = '';
            for (let i = elements.length - 1; i >= 0; i--) {
                const element = elements[i];
                const layer = document.createElement('div');
                layer.className = 'layer-item' + (element === selectedElement ? ' active' : '');
                layer.onclick = () => {
                    selectedElement = element;
                    updatePropertiesPanel();
                    updateLayersList();
                    render();
                };

                let icon = '';
                switch (element.type) {
                    case 'rect': icon = 'â–¢'; break;
                    case 'circle': icon = 'â—‹'; break;
                    case 'triangle': icon = 'â–³'; break;
                    case 'star': icon = 'â˜…'; break;
                    case 'line': icon = 'â”€'; break;
                    case 'arrow': icon = 'â†’'; break;
                    case 'text': icon = 'T'; break;
                    case 'image': icon = 'ğŸ–¼ï¸'; break;
                    case 'pencil': icon = 'âœï¸'; break;
                }

                layer.innerHTML = `
                    <div><span class="layer-icon">${icon}</span>${element.type === 'text' ? element.text.substring(0, 15) : element.type}</div>
                    <div class="layer-actions">
                        <button class="layer-btn" onclick="event.stopPropagation(); toggleLayerVisibility(${i})">${element.visible ? 'ğŸ‘ï¸' : 'ğŸš«'}</button>
                        <button class="layer-btn" onclick="event.stopPropagation(); toggleLayerLock(${i})">${element.locked ? 'ğŸ”’' : 'ğŸ”“'}</button>
                    </div>
                `;
                layersList.appendChild(layer);
            }
        }

        function toggleLayerVisibility(index) {
            const actualIndex = elements.length - 1 - index;
            elements[actualIndex].visible = !elements[actualIndex].visible;
            updateLayersList();
            render();
        }

        function toggleLayerLock(index) {
            const actualIndex = elements.length - 1 - index;
            elements[actualIndex].locked = !elements[actualIndex].locked;
            updateLayersList();
        }

        function moveLayer(direction) {
            if (!selectedElement) return;

            const index = elements.indexOf(selectedElement);
            if (direction === 'up' && index < elements.length - 1) {
                [elements[index], elements[index + 1]] = [elements[index + 1], elements[index]];
            } else if (direction === 'down' && index > 0) {
                [elements[index], elements[index - 1]] = [elements[index - 1], elements[index]];
            }

            updateLayersList();
            render();
        }

        function deleteSelected() {
            if (!selectedElement) return;

            const index = elements.indexOf(selectedElement);
            if (index > -1) {
                elements.splice(index, 1);
                selectedElement = null;
                saveHistory();
                updatePropertiesPanel();
                updateLayersList();
                render();
            }
        }

        function groupElements() {
            if (selectedElements.length < 2) {
                alert('ê·¸ë£¹í™”í•˜ë ¤ë©´ 2ê°œ ì´ìƒì˜ ìš”ì†Œë¥¼ ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            const groupId = nextGroupId++;
            selectedElements.forEach(el => {
                el.groupId = groupId;
            });

            saveHistory();
            alert(`${selectedElements.length}ê°œì˜ ìš”ì†Œê°€ ê·¸ë£¹í™”ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        function ungroupElements() {
            if (!selectedElement || !selectedElement.groupId) {
                alert('ê·¸ë£¹í™”ëœ ìš”ì†Œë¥¼ ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            const groupId = selectedElement.groupId;
            elements.forEach(el => {
                if (el.groupId === groupId) {
                    el.groupId = null;
                }
            });

            saveHistory();
            alert('ê·¸ë£¹ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
        }

        function selectAll() {
            selectedElements = elements.filter(el => el.visible && !el.locked);
            if (selectedElements.length > 0) {
                selectedElement = selectedElements[0];
                updatePropertiesPanel();
                updateLayersList();
                render();
            }
        }

        function copySelected() {
            if (!selectedElement) return;

            clipboard = JSON.parse(JSON.stringify({
                ...selectedElement,
                imageData: null,
                imageDataId: selectedElement.type === 'image' ? selectedElement.id : null
            }));
        }

        function pasteClipboard() {
            if (!clipboard) return;

            const el = new Element(clipboard.type, clipboard.x + 20, clipboard.y + 20, clipboard.width, clipboard.height);
            Object.assign(el, clipboard);
            el.id = Date.now() + Math.random();

            // Restore image data from cache
            if (clipboard.type === 'image' && clipboard.imageDataId) {
                const cachedImage = imageCache.get(clipboard.imageDataId);
                if (cachedImage) {
                    el.imageData = cachedImage;
                    imageCache.set(el.id, cachedImage);
                }
            }

            elements.push(el);
            selectedElement = el;
            selectedElements = [el];
            saveHistory();
            updatePropertiesPanel();
            updateLayersList();
            render();
        }

        function duplicateSelected() {
            if (!selectedElement) return;

            copySelected();
            pasteClipboard();
        }

        function moveSelectedByArrow(key, ctrlKey) {
            if (!selectedElement) return;

            const step = ctrlKey ? 10 : 1;
            const elementsToMove = selectedElements.length > 1 ? selectedElements : [selectedElement];

            elementsToMove.forEach(el => {
                if (el.locked) return;

                switch (key) {
                    case 'ArrowUp':
                        el.y -= step;
                        break;
                    case 'ArrowDown':
                        el.y += step;
                        break;
                    case 'ArrowLeft':
                        el.x -= step;
                        break;
                    case 'ArrowRight':
                        el.x += step;
                        break;
                }
            });

            updatePropertiesPanel();
            render();
        }

        function alignElements(alignment) {
            if (!selectedElement) return;

            switch (alignment) {
                case 'left':
                    selectedElement.x = 0;
                    break;
                case 'center':
                    selectedElement.x = (canvas.width - selectedElement.width) / 2;
                    break;
                case 'right':
                    selectedElement.x = canvas.width - selectedElement.width;
                    break;
                case 'top':
                    selectedElement.y = 0;
                    break;
                case 'middle':
                    selectedElement.y = (canvas.height - selectedElement.height) / 2;
                    break;
                case 'bottom':
                    selectedElement.y = canvas.height - selectedElement.height;
                    break;
            }

            updatePropertiesPanel();
            render();
        }

        function saveHistory() {
            history = history.slice(0, historyIndex + 1);

            // Serialize elements without image data
            const serialized = elements.map(el => {
                const copy = {...el};
                if (el.type === 'image' && el.imageData) {
                    // Cache the image and store only the ID
                    const imageId = el.id;
                    imageCache.set(imageId, el.imageData);
                    copy.imageDataId = imageId;
                    delete copy.imageData;
                }
                return copy;
            });

            history.push(JSON.stringify(serialized));
            historyIndex++;

            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = true;

            // Limit history to 50 entries to prevent memory issues
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreFromHistory();

                document.getElementById('undoBtn').disabled = historyIndex <= 0;
                document.getElementById('redoBtn').disabled = false;
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreFromHistory();

                document.getElementById('undoBtn').disabled = false;
                document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
            }
        }

        function restoreFromHistory() {
            const serialized = JSON.parse(history[historyIndex]);
            elements = serialized.map(data => {
                const el = new Element(data.type, data.x, data.y, data.width, data.height);
                Object.assign(el, data);

                // Restore image data from cache
                if (data.type === 'image' && data.imageDataId) {
                    el.imageData = imageCache.get(data.imageDataId) || null;
                }

                return el;
            });

            selectedElement = null;
            selectedElements = [];
            updatePropertiesPanel();
            updateLayersList();
            render();
        }

        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const element = new Element('image', 100, 100, img.width, img.height);
                    element.imageData = img;
                    elements.push(element);
                    selectedElement = element;
                    saveHistory();
                    updatePropertiesPanel();
                    updateLayersList();
                    render();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function generateAIImage() {
            const prompt = document.getElementById('aiPrompt').value.trim();
            if (!prompt) {
                alert('í”„ë¡¬í”„íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }

            const aiBtn = document.getElementById('aiBtn');
            const aiMessage = document.getElementById('aiMessage');

            aiBtn.disabled = true;
            aiBtn.textContent = 'ìƒì„± ì¤‘...';
            aiMessage.innerHTML = '<div class="message loading">AIê°€ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...</div>';

            try {
                const size = document.getElementById('aiSize').value;
                const response = await fetchWithRetry(`${PYTHON_API_URL}/generate-image`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt, size, quality: 'standard' })
                });

                const data = await response.json();
                if (response.ok && data.success) {
                    const img = new Image();
                    img.onload = function() {
                        const element = new Element('image', 50, 50, 400, 400);
                        element.imageData = img;
                        elements.push(element);
                        selectedElement = element;
                        saveHistory();
                        updatePropertiesPanel();
                        updateLayersList();
                        render();

                        aiMessage.innerHTML = '<div class="message success">ì´ë¯¸ì§€ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!</div>';
                        setTimeout(() => aiMessage.innerHTML = '', 3000);
                    };
                    img.src = data.imageData;
                } else {
                    throw new Error('ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨');
                }
            } catch (error) {
                aiMessage.innerHTML = '<div class="message error">ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</div>';
            } finally {
                aiBtn.disabled = false;
                aiBtn.textContent = 'ì´ë¯¸ì§€ ìƒì„±';
            }
        }

        async function saveProject() {
            if (!currentProjectId) {
                alert('í”„ë¡œì íŠ¸ IDê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const saveMessage = document.getElementById('saveMessage');
            saveMessage.innerHTML = '<div class="message loading">ì €ì¥ ì¤‘...</div>';

            try {
                const token = localStorage.getItem('token');

                // Save canvas as image
                const canvasData = canvas.toDataURL('image/jpeg', 0.8);

                const projectData = {
                    image: canvasData,
                    elements: elements.map(el => ({
                        ...el,
                        imageData: el.imageData ? el.imageData.src : null
                    })),
                    prompt: document.getElementById('aiPrompt').value,
                    lastModified: new Date().toISOString()
                };

                const response = await fetchWithRetry(`${API_URL}/projects/${currentProjectId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({
                        data: JSON.stringify(projectData)
                    })
                });

                if (response.ok) {
                    lastSaveTime = new Date();
                    saveMessage.innerHTML = '<div class="message success">í”„ë¡œì íŠ¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!</div>';
                    setTimeout(() => saveMessage.innerHTML = '', 3000);
                } else {
                    throw new Error('ì €ì¥ ì‹¤íŒ¨');
                }
            } catch (error) {
                saveMessage.innerHTML = '<div class="message error">ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì¬ì‹œë„í•©ë‹ˆë‹¤...</div>';
                console.error('Save error:', error);
            }
        }

        async function loadProject(projectId) {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${API_URL}/projects/${projectId}`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });

                if (response.ok) {
                    const project = await response.json();
                    document.getElementById('projectName').textContent = project.name;

                    if (project.data) {
                        try {
                            const data = JSON.parse(project.data);
                            if (data.prompt) {
                                document.getElementById('aiPrompt').value = data.prompt;
                            }
                            if (data.elements) {
                                // Restore elements
                                elements = [];
                                for (let elData of data.elements) {
                                    const el = new Element(elData.type, elData.x, elData.y, elData.width, elData.height);
                                    Object.assign(el, elData);

                                    if (elData.imageData) {
                                        const img = new Image();
                                        img.onload = () => render();
                                        img.src = elData.imageData;
                                        el.imageData = img;
                                    }

                                    elements.push(el);
                                }
                                saveHistory();
                                updateLayersList();
                                render();
                            } else if (data.image) {
                                // Load legacy image
                                const img = new Image();
                                img.onload = function() {
                                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                };
                                img.src = data.image;
                            }
                        } catch (e) {
                            console.log('No saved data');
                            render();
                        }
                    } else {
                        render();
                    }
                }
            } catch (error) {
                console.error('Load error:', error);
                render();
            }
        }
    </script>
</body>
</html>
